# Zero-Knowledge HyperDimensional (ZKHD)

> **Disclaimer**
>
> This is a prototype implementation for educational and research purposes. It simulates the cryptographic and biometric concepts described in the associated paper but is not intended for production use. The fuzzy extractor is a simplified stub, and all performance metrics are simulated.

## Overview

This project provides a Python simulation of the ZKHD (Zero-Knowledge HyperDimensional) authentication framework. ZKHD is a novel theoretical protocol designed for passwordless authentication that proves a user's identity without any reusable secrets being stored on a server or transmitted over a network. The core idea is to combine two concepts:

**Hyperdimensional Computing (HDC):** Live biometric sensor data (simulated in this prototype) is converted into a unique, high-dimensional "hypervector." This process is robust to the natural noise and variations in biometric readings.

**Zero-Knowledge Proof (ZKP):** The user derives a stable cryptographic key from their hypervector and then proves knowledge of this key to a server without ever revealing it.

This implementation simulates the complete protocol flow, from user enrollment to authentication, and includes tests for the False Rejection Rate (FRR) under different noise conditions.

## How It Works

The simulation is divided into two main phases: Enrollment and Authentication.

### 1. Enrollment (`register`)

**Simulate Biometrics:** Unique biometric data (keystroke dynamics, accelerometer, heart rate) is generated for a user (`sensor_sim.py`).

**Encode to Hypervector:** This data is encoded into a single, 10,000-dimension bipolar hypervector (`v_ref`) using HDC operations (`hypervector.py`).

**Generate Secrets:**
     A stable secret binary vector `S` is derived from `v_ref`.
     A cryptographic private key `k` is generated by hashing `S` with SHA-512.

**Store Public Data:** The server stores only non-sensitive public data:
     `S`: The "helper data" for the fuzzy extractor. In a real system, this would be a syndrome, but here it is the secret itself for simulation purposes.
     `P`: The public key corresponding to the private key `k`.
     The private key `k` is immediately discarded.

### 2. Authentication (`login`)

**New Biometrics:** New biometric data is simulated for the user, and a specified level of noise is added to it to mimic real-world variations.

**Encode Noisy Vector:** The noisy data is encoded into a new hypervector, `v_prime_noisy`.

**Reproduce Secret:** The simplified **Fuzzy Extractor** (`fuzzy_extractor.py`) attempts to reproduce the original secret vector `S`. It does this by checking if the Hamming distance between the new noisy vector and the stored `S` is within a pre-defined tolerance threshold (3.8%).

**Re-derive Key:** If reproduction is successful, the exact same private key `k` is re-derived by hashing the reproduced `S`. If reproduction fails, authentication fails.

**Prove Knowledge (ZKP):** The client uses the re-derived key `k` to generate a Schnorr-like Zero-Knowledge Proof (`R`, `s`) that it knows the key corresponding to the public key `P` (`zk_protocol.py`). A unique `session_id` is included to prevent replay attacks.
6.  **Verify Proof:** The server receives the proof (`R`, `s`) and verifies it using the stored public key `P` and the same `session_id`. If the proof is valid, authentication is successful.

## Screenshots
![Screenshot-3](https://github.com/user-attachments/assets/c0ad9ccc-ae09-4bab-9e86-f3919b2fc634)



## Project Structure

* `main.py`: The main script to run the enrollment, login, and FRR simulations.
* `sensor_sim.py`: Simulates biometric data streams for keystroke, accelerometer, and heart rate.
* `hypervector.py`: Implements the HDC encoding model, converting sensor data into 10,000-dimensional hypervectors.
* `fuzzy_extractor.py`: A simplified simulation of a fuzzy extractor using a Hamming distance check for key reproduction.
* `zk_protocol.py`: Implements the Prover and Verifier for the Zero-Knowledge Proof protocol using the `pynacl` (libsodium) library for Ed25519 signatures.

### Requirements

Just Python 3 and the following libraries:
* `numpy`
* `pynacl`

Install them using pip:
```bash
pip install numpy pynacl
```

## How to Run
NOTE: You can adjust the number of FRR tests in `main.py` `frr()` function. You can also adjust the noise level in `main.py` `test()` function.

```bash
python main.py
```
